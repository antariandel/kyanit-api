<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>Kyanit API Documentation</title>
<meta name="description" content="Kyanit API …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>
/* Hide "Module kyanitapi" title */
h1.title {
display: none;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kyanitapi</code></h1>
</header>
<section id="section-intro">
<h1 id="kyanit-api">Kyanit API</h1>
<p>Kyanit API is a Python API for interfacing and interacting with Kyanit.</p>
<p>For a command-line utility, see Kyanit CTL at <a href="https://kyanit.eu/docs/kyanit-ctl.">https://kyanit.eu/docs/kyanit-ctl.</a></p>
<p>Install the latest released version of Kyanit API from PyPI with:</p>
<pre><code>pip install kyanitapi
</code></pre>
<p>Then import the module with:</p>
<pre><code class="python">import kyanitapi
</code></pre>
<p>The module publishes the <a title="kyanitapi.Kyanit" href="#kyanitapi.Kyanit"><code>Kyanit</code></a> class to connect to Kyanit boards. Import the class directly with:</p>
<pre><code class="python">from kyanitapi import Kyanit
</code></pre>
<p>Kyanit provides an addressing mechanism called the "Color ID," which mapps to the IP address of the
Kyanit board. The Color ID consists of 3 colors from the <strong>R</strong>ed, <strong>G</strong>reen, <strong>B</strong>lue, <strong>C</strong>yan,
<strong>M</strong>agenta, <strong>Y</strong>ellow and <strong>W</strong>hite pallette. If you don't know how to find out the Color ID of
a Kyanit board, head to Kyanit's documentation at: <a href="https://kyanit.eu/docs">https://kyanit.eu/docs</a></p>
<p>Addressing using the Color ID works on home networks with a subnet mask of 255.255.255.0, which is
what most home and small business routers create. Assuming you know the Color ID of the board, and
the network address to which it's connected, you can instantiate the <a title="kyanitapi.Kyanit" href="#kyanitapi.Kyanit"><code>Kyanit</code></a> class with:</p>
<pre><code class="python">my_kyanit = Kyanit('BCG', '192.168.1.0')
</code></pre>
<p>Where 'BCG' is the Color ID of the board and '192.168.1.0' is the network address.</p>
<p>On non-255.255.255.0 networks, it is possible to connect to the Kyanit board providing only it's IP
address:</p>
<pre><code class="python">my_kyanit = Kyanit(ip_addr='192.168.1.6')
</code></pre>
<p>Once instantiated, you can perform all sorts of actions on your Kyanit board. You can ping the board
with <a title="kyanitapi.Kyanit.ping" href="#kyanitapi.Kyanit.ping"><code>Kyanit.ping()</code></a>, get its status with <a title="kyanitapi.Kyanit.get_status" href="#kyanitapi.Kyanit.get_status"><code>Kyanit.get_status()</code></a>, and perform file operations like
listing the files on the board with <a title="kyanitapi.Kyanit.get_file_list" href="#kyanitapi.Kyanit.get_file_list"><code>Kyanit.get_file_list()</code></a> or downloading and uploading files with
<a title="kyanitapi.Kyanit.get_file" href="#kyanitapi.Kyanit.get_file"><code>Kyanit.get_file()</code></a> and <a title="kyanitapi.Kyanit.put_file" href="#kyanitapi.Kyanit.put_file"><code>Kyanit.put_file()</code></a> respectively. Other file actions, like delete and rename are
also possible.</p>
<p>System-level operations are provided as well, these being the <a title="kyanitapi.Kyanit.reboot" href="#kyanitapi.Kyanit.reboot"><code>Kyanit.reboot()</code></a>, which re-initializes
the board, <a title="kyanitapi.Kyanit.stop" href="#kyanitapi.Kyanit.stop"><code>Kyanit.stop()</code></a> and <a title="kyanitapi.Kyanit.start" href="#kyanitapi.Kyanit.start"><code>Kyanit.start()</code></a> which stop and start the user code.</p>
<p>Kyanit also provides a notion of a "network variable" called the Netvar, which can be accessed with
the <a title="kyanitapi.Kyanit.netvar" href="#kyanitapi.Kyanit.netvar"><code>Kyanit.netvar()</code></a> method.</p>
<p>Here's an example in the REPL to demonstrate some of these actions:</p>
<pre><code class="python">&gt;&gt;&gt; from kyanitapi import Kyanit
&gt;&gt;&gt; my_kyanit = Kyanit('BCG', '192.168.1.0')
&gt;&gt;&gt; my_kyanit.ping()
True
&gt;&gt;&gt; my_kyanit.get_status()
{'free_flash': 3514368, 'free_memory': 18768, 'run_state': 'CODE.PY MAIN', ...}
&gt;&gt;&gt; my_kyanit.get_file_list()
['wlan.json', 'code.py']
&gt;&gt;&gt; my_kyanit.put_file('some_file.txt', 'some text')
'OK'
&gt;&gt;&gt; my_kyanit.get_file_list()
['wlan.json', 'code.py', 'some_file.txt']
&gt;&gt;&gt; my_kyanit.get_file('some_file.txt')
b'some text'
&gt;&gt;&gt; my_kyanit.delete_file('some_file.txt')
'OK'
&gt;&gt;&gt; my_kyanit.get_file_list()
['wlan.json', 'code.py']
&gt;&gt;&gt; my_kyanit.stop()
'OK'
&gt;&gt;&gt; my_kyanit.get_status()
{'free_flash': 3514368, 'free_memory': 20288, 'run_state': 'STOPPED', ...}
&gt;&gt;&gt; my_kyanit.start()
'OK'
&gt;&gt;&gt; my_kyanit.get_status()
{'free_flash': 3514368, 'free_memory': 17744, 'run_state': 'CODE.PY MAIN', ...}
</code></pre>
<p>See the <a title="kyanitapi.Kyanit" href="#kyanitapi.Kyanit"><code>Kyanit</code></a> class and module function documentations to see what the class and this module can
do.</p>
<h1 id="license-notice">License Notice</h1>
<p>Copyright (C) 2020 Zsolt Nagy</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the
GNU General Public License as published by the Free Software Foundation, version 3 of the License.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.
If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Kyanit API
# Copyright (C) 2020 Zsolt Nagy
#
# This program is free software: you can redistribute it and/or modify it under the terms of the
# GNU General Public License as published by the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program.
# If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;
# Kyanit API

Kyanit API is a Python API for interfacing and interacting with Kyanit.

For a command-line utility, see Kyanit CTL at https://kyanit.eu/docs/kyanit-ctl.

Install the latest released version of Kyanit API from PyPI with:

```
pip install kyanitapi
```

Then import the module with:

```python
import kyanitapi
```

The module publishes the `Kyanit` class to connect to Kyanit boards. Import the class directly with:

```python
from kyanitapi import Kyanit
```

Kyanit provides an addressing mechanism called the &#34;Color ID,&#34; which mapps to the IP address of the
Kyanit board. The Color ID consists of 3 colors from the **R**ed, **G**reen, **B**lue, **C**yan,
**M**agenta, **Y**ellow and **W**hite pallette. If you don&#39;t know how to find out the Color ID of
a Kyanit board, head to Kyanit&#39;s documentation at: https://kyanit.eu/docs

Addressing using the Color ID works on home networks with a subnet mask of 255.255.255.0, which is
what most home and small business routers create. Assuming you know the Color ID of the board, and
the network address to which it&#39;s connected, you can instantiate the `Kyanit` class with:

```python
my_kyanit = Kyanit(&#39;BCG&#39;, &#39;192.168.1.0&#39;)
```

Where &#39;BCG&#39; is the Color ID of the board and &#39;192.168.1.0&#39; is the network address.

On non-255.255.255.0 networks, it is possible to connect to the Kyanit board providing only it&#39;s IP
address:

```python
my_kyanit = Kyanit(ip_addr=&#39;192.168.1.6&#39;)
```

Once instantiated, you can perform all sorts of actions on your Kyanit board. You can ping the board
with `Kyanit.ping`, get its status with `Kyanit.get_status`, and perform file operations like
listing the files on the board with `Kyanit.get_file_list` or downloading and uploading files with
`Kyanit.get_file` and `Kyanit.put_file` respectively. Other file actions, like delete and rename are
also possible.

System-level operations are provided as well, these being the `Kyanit.reboot`, which re-initializes
the board, `Kyanit.stop` and `Kyanit.start` which stop and start the user code.

Kyanit also provides a notion of a &#34;network variable&#34; called the Netvar, which can be accessed with
the `Kyanit.netvar` method.

Here&#39;s an example in the REPL to demonstrate some of these actions:

```python
&gt;&gt;&gt; from kyanitapi import Kyanit
&gt;&gt;&gt; my_kyanit = Kyanit(&#39;BCG&#39;, &#39;192.168.1.0&#39;)
&gt;&gt;&gt; my_kyanit.ping()
True
&gt;&gt;&gt; my_kyanit.get_status()
{&#39;free_flash&#39;: 3514368, &#39;free_memory&#39;: 18768, &#39;run_state&#39;: &#39;CODE.PY MAIN&#39;, ...}
&gt;&gt;&gt; my_kyanit.get_file_list()
[&#39;wlan.json&#39;, &#39;code.py&#39;]
&gt;&gt;&gt; my_kyanit.put_file(&#39;some_file.txt&#39;, &#39;some text&#39;)
&#39;OK&#39;
&gt;&gt;&gt; my_kyanit.get_file_list()
[&#39;wlan.json&#39;, &#39;code.py&#39;, &#39;some_file.txt&#39;]
&gt;&gt;&gt; my_kyanit.get_file(&#39;some_file.txt&#39;)
b&#39;some text&#39;
&gt;&gt;&gt; my_kyanit.delete_file(&#39;some_file.txt&#39;)
&#39;OK&#39;
&gt;&gt;&gt; my_kyanit.get_file_list()
[&#39;wlan.json&#39;, &#39;code.py&#39;]
&gt;&gt;&gt; my_kyanit.stop()
&#39;OK&#39;
&gt;&gt;&gt; my_kyanit.get_status()
{&#39;free_flash&#39;: 3514368, &#39;free_memory&#39;: 20288, &#39;run_state&#39;: &#39;STOPPED&#39;, ...}
&gt;&gt;&gt; my_kyanit.start()
&#39;OK&#39;
&gt;&gt;&gt; my_kyanit.get_status()
{&#39;free_flash&#39;: 3514368, &#39;free_memory&#39;: 17744, &#39;run_state&#39;: &#39;CODE.PY MAIN&#39;, ...}
```

See the `Kyanit` class and module function documentations to see what the class and this module can
do.

# License Notice

Copyright (C) 2020 Zsolt Nagy

This program is free software: you can redistribute it and/or modify it under the terms of the
GNU General Public License as published by the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.
If not, see &lt;https://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;


import json
import psutil
import requests
import ipaddress
import pythonping

from functools import wraps

try:
    from ._version import __version__
except ImportError:
    pass


VALID_ID_COLORS = [&#39;B&#39;, &#39;C&#39;, &#39;G&#39;, &#39;M&#39;, &#39;R&#39;, &#39;W&#39;, &#39;Y&#39;]


def get_networks():
    &#34;&#34;&#34;
    Return a list with networks that have a netmask of 255.255.255.0 in the current system.
    Only such networks are supported for connecting to a Kyanit using the Color ID.

    Return an empty list, if no such networks are found.

    List items will be tuples in the form of `(&#39;Interface Name&#39;, &#39;&lt;ip_address&gt;&#39;)`, such as
    `(&#39;eth0&#39;, &#39;192.168.1.0&#39;)` or `(&#39;Local Area Connection&#39;, &#39;192.168.3.0&#39;)` depending on the
    operating system.
    &#34;&#34;&#34;

    all_interfaces = psutil.net_if_addrs()
    networks = []
    for if_name in all_interfaces:
        for nic_address in all_interfaces[if_name]:
            if nic_address.netmask == &#39;255.255.255.0&#39;:
                networks.append((if_name,
                    # store network address
                    str(ipaddress.IPv4Network(&#39;{}/24&#39;.format(nic_address.address), strict=False)
                        .network_address)))  # noqa
    return networks


def cid_is_valid(color_id):
    &#34;&#34;&#34;
    Return `True` if `color_id` is a valid Color ID string, and `False` otherwise.
    
    &#39;BBB&#39; (an address of 0) is not considered to be valid, and neither is any ID representing an
    address above 254.
    &#34;&#34;&#34;

    if not isinstance(color_id, str):
        return False
    if len(color_id) != 3:
        return False
    color_id = color_id.upper()
    for symbol in color_id:
        if symbol not in VALID_ID_COLORS:
            return False
    # Color ID must result in an IP octet between 1 and 254
    num = 0
    for symbol in enumerate(color_id[::-1]):
        num += len(VALID_ID_COLORS) ** symbol[0] * VALID_ID_COLORS.index(symbol[1])
    if num &lt; 1 or num &gt; 254:
        return False
    return True


def ip_is_valid(ip_addr):
    &#34;&#34;&#34;
    Return `True` if `ip_addr` is a valid IP address string, and `False` otherwise.
    &#34;&#34;&#34;

    try:
        ipaddress.IPv4Network(ip_addr)
    except ipaddress.AddressValueError:
        return False
    else:
        return True


def netmask_is_valid(netmask):
    &#34;&#34;&#34;
    Return `True` if `netmask` is a valid netmask string, and `False` otherwise.
    &#34;&#34;&#34;

    try:
        ipaddress.IPv4Network(&#39;0.0.0.0/{}&#39;.format(netmask))
    except ipaddress.NetmaskValueError:
        return False
    else:
        return True


def ip_to_cid(ip_addr):
    &#34;&#34;&#34;
    Convert an IP address string to a Color ID. It is assumed that the IP address is from a network
    with a netmask of 255.255.255.0.
    
    If the passed IP address is not valid, `ValueError: IP invalid` will be raised.
    
    Returned value is the Color ID string.
    &#34;&#34;&#34;

    if not ip_is_valid(ip_addr):
        raise ValueError(&#39;IP invalid&#39;)
    num = int(ip_addr.split(&#39;.&#39;)[3])
    max_addr = len(VALID_ID_COLORS) ** 3 - 1
    if num &lt; 0 or num &gt; max_addr:
        # this should never be raised if VALID_ID_COLORS has at least 7 symbols.
        raise ValueError()
    base = len(VALID_ID_COLORS)
    symbols = VALID_ID_COLORS
    digits = []
    while num:
        digits.append(symbols[int(num % base)])
        num = int(num / base)
    digits.reverse()
    result = &#39;&#39;.join(digits)
    return (symbols[0] * (3 - len(result))) + result


def cid_to_ip(color_id, network_addr):
    &#34;&#34;&#34;
    Convert a Color ID to an IP address within the network given in `network_addr`.
    
    If `color_id` is not a valid Color ID, `ValueError: Color ID invalid` will be raised.
    Consequently if `network_addr` is not a valid address,`ValueError: Network invalid` will be
    raised. The last octet of `network_addr` must be zero, and a subnet mask of 255.255.255.0 is
    assumed.
    
    Returned value is an IP address string.
    &#34;&#34;&#34;

    if not cid_is_valid(color_id):
        raise ValueError(&#39;Color ID invalid&#39;)
    if not ip_is_valid(network_addr):
        raise ValueError(&#39;Network invalid&#39;)
    if ipaddress.IPv4Address(network_addr).packed[3] != 0:
        raise ValueError(&#39;Network invalid&#39;)
    num = 0
    for symbol in enumerate(color_id[::-1]):
        num += len(VALID_ID_COLORS) ** symbol[0] * VALID_ID_COLORS.index(symbol[1])
    ip = network_addr.split(&#39;.&#39;)
    ip[3] = str(num)
    return &#39;.&#39;.join(ip)


class KyanitConnectionError(Exception):
    &#34;&#34;&#34;
    Raised when connecting to Kyanit fails or results in a timeout. No arguments are passed to
    this exception.

    Handle it as follows:

    ```python
    try:
        # some Kyanit operation
        ...
    except KyanitConnectionError:
        # do something on connection error
    ```
    &#34;&#34;&#34;
    pass


class KyanitRequestError(Exception):
    &#34;&#34;&#34;
    Raised when Kyanit responds with a status code other than 200 OK. The first argument passed
    to this exception will be the response status code, the second will be the response body.

    Handle it as follows:

    ```python
    try:
        # some Kyanit operation
        ...
    except KyanitRequestError as error:
        status_code = error.args[0]
        response_body = error.args[1]
        
        if status_code == 404:
            # do something on 404 Not Found
            ...
        
        # handle the rest, if desired
        ...
    ```
    &#34;&#34;&#34;
    pass


def _request_handler(rtype=None):
    # returns a decorator, rtype can be &#39;json&#39;, &#39;text&#39; or None, which determines the format in which
    # the response body will be returned
    def decorated(func):
        # decorator to handle requests and request errors
        @wraps(func)
        def handle_request(*args, **kwargs):
            conn_error = False
            try:
                response = func(*args, **kwargs)
            except (requests.exceptions.Timeout, OSError):
                # discard the chain, it&#39;s a connection error
                conn_error = True
            if conn_error:
                raise KyanitConnectionError
            if response.status_code != 200:
                raise KyanitRequestError(response.status_code,
                                         response.json()[&#39;error&#39;]
                                         if &#39;error&#39; in response.json() else
                                         None)
            else:
                if rtype == &#39;json&#39;:
                    return response.json()
                elif rtype == &#39;text&#39;:
                    return response.text
                return response.content
        return handle_request
    return decorated


class Kyanit:
    &#34;&#34;&#34;
    Class for a Kyanit connection instance. No connection attempt is made on instantiation.

    Provide either a Color ID with a Network address OR an IP address. These can not be changed
    after instantiation. Timeout is in seconds.

    If both Color ID and IP address are provided, `ValueError: bad connection method` will be
    raised. If neither is provided, `ValueError: no connection method` will be raised.

    All methods that perform a request towards Kyanit will be blocking until a response is received
    or the request is timed out.
    &#34;&#34;&#34;

    def __init__(self, color_id=None, network_addr=None, ip_addr=None, timeout=3):
        if color_id is not None and ip_addr is not None:
            raise ValueError(&#39;bad connection method&#39;)
        elif color_id is None and ip_addr is None:
            raise ValueError(&#39;no connection method&#39;)
        
        if color_id is not None:
            self._ip_addr = cid_to_ip(color_id, network_addr=network_addr)
            self._color_id = color_id
        
        elif ip_addr is not None:
            self._color_id = ip_to_cid(ip_addr)
            self._ip_addr = ip_addr

        self._network_addr = network_addr
        self.set_timeout(timeout)
    
    def info(self):
        &#34;&#34;&#34;
        Return connection info.

        Return value is a dict with the following schema:

        ```python
        {
            &#39;color_id&#39;: str,
            &#39;network_addr&#39;: str,
            &#39;ip_addr&#39;: str
        }
        ```
        &#34;&#34;&#34;

        return {
            &#39;color_id&#39;: self._color_id,
            &#39;network_addr&#39;: self._network_addr,
            &#39;ip_addr&#39;: self._ip_addr
        }
    
    def set_timeout(self, seconds):
        &#34;&#34;&#34;
        Set connection timeout in seconds.
        &#34;&#34;&#34;

        self._timeout = seconds
    
    def ping(self, count=3, timeout=1, verbose=False):
        &#34;&#34;&#34;
        Ping Kyanit.
        
        You may provide ping count and timeout in seconds. If verbose is `True`, results will be
        printed.

        Return value is `True` is ping was successful, `False` otherwise
        &#34;&#34;&#34;

        return pythonping.ping(self._ip_addr,
                               count=count,
                               timeout=timeout,
                               verbose=verbose).success()

    def get_status(self, tries=1):
        &#34;&#34;&#34;
        Get status of Kyanit. Getting status will be attempted a number of times defined in `tries`.
        Each try may time out, therefore getting status may take `tries * self.timeout` amount of
        time. (Useful after some longer operation, ex. directly after reboot.)

        Returned value will be a dict with the following schema:

        ```python
        {
            &#39;firmware_version&#39;: str,  # version number in the format major.minor.patch
            &#39;color_id&#39;: str,  # current Color ID of the Kyanit
            &#39;free_memory&#39;: int,  # free heap RAM in bytes
            &#39;free_flash&#39;: int,  # amount of bytes free in the filesystem
            &#39;run_state&#39;: str,  # see note below
            &#39;error_traceback&#39;: [
                str
            ] # key is present if run_state is ERROR, and contains the traceback lines
        }
        ```

        Note: for possible run states see https://github.com/kyanit-project/kyanit#run-states
        &#34;&#34;&#34;
        
        num_tries = 0
        while True:
            try:
                data = requests.get(&#39;http://{}:3300/sys/state&#39;.format(self._ip_addr),
                                    timeout=self._timeout)
            except Exception:
                num_tries += 1
                if num_tries &gt;= tries:
                    break
            else:
                return data.json()
        raise KyanitConnectionError
    
    @_request_handler(&#39;json&#39;)
    def stop(self, force=False):
        &#34;&#34;&#34;
        Stop runner, stopping all tasks. New run state will be &#39;STOPPED&#39;.

        A kyanit.StoppedError will be passed to code.cleanup on Kyanit.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.post(&#39;http://{}:3300/sys/stop{}&#39;
                             .format(self._ip_addr, &#39;/force&#39; if force else &#39;&#39;),
                             timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def start(self):
        &#34;&#34;&#34;
        Start runner. Kyanit will attempt to import &#39;code.py&#39; and call main.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.post(&#39;http://{}:3300/sys/start&#39;.format(self._ip_addr),
                             timeout=self._timeout)
    
    # @_request_handler(&#39;json&#39;)
    # def reset(self, soft=False):
    #     &#34;&#34;&#34;
    #     Perform a soft reset on the Kyanit. The system will restart, but the wlan connection will
    #     be preserved, if unchanged.

    #     kyanit.ResetError will be passed to code.cleanup on Kyanit before the reset procedure.

    #     Might take some time before Kyanit will respond to further requests. It&#39;s a good practice
    #     to `get_status` with a number of tries larger than 1 (ex. 5) after reboot or reset.

    #     Return value is the string `OK` if successful.
    #     &#34;&#34;&#34;

    #     return requests.post(&#39;http://{}:3300/sys/reboot/soft&#39;.format(self._ip_addr),
    #                          timeout=self._timeout)

    @_request_handler(&#39;json&#39;)
    def reboot(self):
        &#34;&#34;&#34;
        Perform a hard reset on the Kyanit. The system will fully restart, wlan connection will
        be performed again.

        kyanit.RebootError will be passed to code.cleanup on Kyanit before the reboot procedure.

        Might take some time before Kyanit will respond to further requests. It&#39;s a good practice to
        `get_status` with a number of tries larger than 1 (ex. 5) after reboot or reset.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.post(&#39;http://{}:3300/sys/reboot&#39;.format(self._ip_addr),
                             timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def get_file_list(self):
        &#34;&#34;&#34;
        Return a list with all of the file names present on Kyanit.
        &#34;&#34;&#34;

        return requests.get(&#39;http://{}:3300/files&#39;.format(self._ip_addr),
                            timeout=self._timeout)
    
    @_request_handler()
    def get_file(self, filename):
        &#34;&#34;&#34;
        Get the contents of the file with the name passed to `filename` from Kyanit.

        `KyanitRequestError` with status code 404 will be raised if file is not found.

        Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
        raised with a status code 500. The same error will be raised if trying to get `main.py`,
        `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

        Return type is bytes (the contents of the file).
        &#34;&#34;&#34;

        return requests.get(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename),
                            timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def put_file(self, filename, content):
        &#34;&#34;&#34;
        Create or replace a file with the name passed to `filename` on the Kyanit, and upload
        contents passed to `content`, which may be bytes or string.

        Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
        raised with a status code 500. The same error will be raised if trying to put `main.py`,
        `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.put(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename), content,
                            timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def delete_file(self, filename):
        &#34;&#34;&#34;
        Delete a file with the name passed to `filename` on the Kyanit.

        `KyanitRequestError` with status code 404 will be raised if file is not found.

        Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
        raised with a status code 500. The same error will be raised if trying to delete
        `main.py`, `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.delete(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename),
                               timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def rename_file(self, filename, newname):
        &#34;&#34;&#34;
        Rename a file with the name passed to `filename` to `newname` on the Kyanit.

        `KyanitRequestError` with status code 404 will be raised if file is not found.

        Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
        raised with a status code 500. The same error will be raised if trying to rename
        `main.py`, `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.
        &#34;&#34;&#34;

        return requests.put(&#39;http://{}:3300/files/{}?rename={}&#39;
                            .format(self._ip_addr, filename, newname),
                            timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def netvar(self, obj=None, clear=False):
        &#34;&#34;&#34;
        Read or write the Netvar on Kyanit.

        If `obj` is `None`, return the value of Netvar.outbound() from Kyanit.

        If `obj` is other than `None`, set the value of Netvar.inbound() on the Kyanit. In that case
        return value is the string &#39;OK&#39; if successful. Otherwise `TypeError` will be raised if `obj`
        is not JSON serializable.

        If `clear` is `True`, `obj` is disregarded and Netvar.inbound() will be set to `None` on the
        Kyanit.

        Examples:

        Get Netvar.inbound() with:

        ```python
        Kyanit.netvar()
        ```

        Set Netvar.outbound() with:

        ```python
        Kyanit.netvar(&#39;new_value&#39;)  # new_value can be any Python object that&#39;s JSON serializable
        ```

        Clear Netvar.outbound() with:

        ```python
        Kyanit.netvar(clear=True)
        ```

        See https://github.com/kyanit-project/kyanit#the-netvar for more on Netvar.
        &#34;&#34;&#34;

        if clear:
            return requests.post(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr), json.dumps(None),
                                 timeout=self._timeout)

        if obj is None:
            return requests.get(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr),
                                timeout=self._timeout)
        else:
            return requests.post(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr), json.dumps(obj),
                                 timeout=self._timeout)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kyanitapi.cid_is_valid"><code class="name flex">
<span>def <span class="ident">cid_is_valid</span></span>(<span>color_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Return <code>True</code> if <code>color_id</code> is a valid Color ID string, and <code>False</code> otherwise.</p>
<p>'BBB' (an address of 0) is not considered to be valid, and neither is any ID representing an
address above 254.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cid_is_valid(color_id):
    &#34;&#34;&#34;
    Return `True` if `color_id` is a valid Color ID string, and `False` otherwise.
    
    &#39;BBB&#39; (an address of 0) is not considered to be valid, and neither is any ID representing an
    address above 254.
    &#34;&#34;&#34;

    if not isinstance(color_id, str):
        return False
    if len(color_id) != 3:
        return False
    color_id = color_id.upper()
    for symbol in color_id:
        if symbol not in VALID_ID_COLORS:
            return False
    # Color ID must result in an IP octet between 1 and 254
    num = 0
    for symbol in enumerate(color_id[::-1]):
        num += len(VALID_ID_COLORS) ** symbol[0] * VALID_ID_COLORS.index(symbol[1])
    if num &lt; 1 or num &gt; 254:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="kyanitapi.cid_to_ip"><code class="name flex">
<span>def <span class="ident">cid_to_ip</span></span>(<span>color_id, network_addr)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert a Color ID to an IP address within the network given in <code>network_addr</code>.</p>
<p>If <code>color_id</code> is not a valid Color ID, <code>ValueError: Color ID invalid</code> will be raised.
Consequently if <code>network_addr</code> is not a valid address,<code>ValueError: Network invalid</code> will be
raised. The last octet of <code>network_addr</code> must be zero, and a subnet mask of 255.255.255.0 is
assumed.</p>
<p>Returned value is an IP address string.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cid_to_ip(color_id, network_addr):
    &#34;&#34;&#34;
    Convert a Color ID to an IP address within the network given in `network_addr`.
    
    If `color_id` is not a valid Color ID, `ValueError: Color ID invalid` will be raised.
    Consequently if `network_addr` is not a valid address,`ValueError: Network invalid` will be
    raised. The last octet of `network_addr` must be zero, and a subnet mask of 255.255.255.0 is
    assumed.
    
    Returned value is an IP address string.
    &#34;&#34;&#34;

    if not cid_is_valid(color_id):
        raise ValueError(&#39;Color ID invalid&#39;)
    if not ip_is_valid(network_addr):
        raise ValueError(&#39;Network invalid&#39;)
    if ipaddress.IPv4Address(network_addr).packed[3] != 0:
        raise ValueError(&#39;Network invalid&#39;)
    num = 0
    for symbol in enumerate(color_id[::-1]):
        num += len(VALID_ID_COLORS) ** symbol[0] * VALID_ID_COLORS.index(symbol[1])
    ip = network_addr.split(&#39;.&#39;)
    ip[3] = str(num)
    return &#39;.&#39;.join(ip)</code></pre>
</details>
</dd>
<dt id="kyanitapi.get_networks"><code class="name flex">
<span>def <span class="ident">get_networks</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a list with networks that have a netmask of 255.255.255.0 in the current system.
Only such networks are supported for connecting to a Kyanit using the Color ID.</p>
<p>Return an empty list, if no such networks are found.</p>
<p>List items will be tuples in the form of <code>('Interface Name', '&lt;ip_address&gt;')</code>, such as
<code>('eth0', '192.168.1.0')</code> or <code>('Local Area Connection', '192.168.3.0')</code> depending on the
operating system.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_networks():
    &#34;&#34;&#34;
    Return a list with networks that have a netmask of 255.255.255.0 in the current system.
    Only such networks are supported for connecting to a Kyanit using the Color ID.

    Return an empty list, if no such networks are found.

    List items will be tuples in the form of `(&#39;Interface Name&#39;, &#39;&lt;ip_address&gt;&#39;)`, such as
    `(&#39;eth0&#39;, &#39;192.168.1.0&#39;)` or `(&#39;Local Area Connection&#39;, &#39;192.168.3.0&#39;)` depending on the
    operating system.
    &#34;&#34;&#34;

    all_interfaces = psutil.net_if_addrs()
    networks = []
    for if_name in all_interfaces:
        for nic_address in all_interfaces[if_name]:
            if nic_address.netmask == &#39;255.255.255.0&#39;:
                networks.append((if_name,
                    # store network address
                    str(ipaddress.IPv4Network(&#39;{}/24&#39;.format(nic_address.address), strict=False)
                        .network_address)))  # noqa
    return networks</code></pre>
</details>
</dd>
<dt id="kyanitapi.ip_is_valid"><code class="name flex">
<span>def <span class="ident">ip_is_valid</span></span>(<span>ip_addr)</span>
</code></dt>
<dd>
<section class="desc"><p>Return <code>True</code> if <code>ip_addr</code> is a valid IP address string, and <code>False</code> otherwise.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ip_is_valid(ip_addr):
    &#34;&#34;&#34;
    Return `True` if `ip_addr` is a valid IP address string, and `False` otherwise.
    &#34;&#34;&#34;

    try:
        ipaddress.IPv4Network(ip_addr)
    except ipaddress.AddressValueError:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="kyanitapi.ip_to_cid"><code class="name flex">
<span>def <span class="ident">ip_to_cid</span></span>(<span>ip_addr)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert an IP address string to a Color ID. It is assumed that the IP address is from a network
with a netmask of 255.255.255.0.</p>
<p>If the passed IP address is not valid, <code>ValueError: IP invalid</code> will be raised.</p>
<p>Returned value is the Color ID string.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ip_to_cid(ip_addr):
    &#34;&#34;&#34;
    Convert an IP address string to a Color ID. It is assumed that the IP address is from a network
    with a netmask of 255.255.255.0.
    
    If the passed IP address is not valid, `ValueError: IP invalid` will be raised.
    
    Returned value is the Color ID string.
    &#34;&#34;&#34;

    if not ip_is_valid(ip_addr):
        raise ValueError(&#39;IP invalid&#39;)
    num = int(ip_addr.split(&#39;.&#39;)[3])
    max_addr = len(VALID_ID_COLORS) ** 3 - 1
    if num &lt; 0 or num &gt; max_addr:
        # this should never be raised if VALID_ID_COLORS has at least 7 symbols.
        raise ValueError()
    base = len(VALID_ID_COLORS)
    symbols = VALID_ID_COLORS
    digits = []
    while num:
        digits.append(symbols[int(num % base)])
        num = int(num / base)
    digits.reverse()
    result = &#39;&#39;.join(digits)
    return (symbols[0] * (3 - len(result))) + result</code></pre>
</details>
</dd>
<dt id="kyanitapi.netmask_is_valid"><code class="name flex">
<span>def <span class="ident">netmask_is_valid</span></span>(<span>netmask)</span>
</code></dt>
<dd>
<section class="desc"><p>Return <code>True</code> if <code>netmask</code> is a valid netmask string, and <code>False</code> otherwise.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netmask_is_valid(netmask):
    &#34;&#34;&#34;
    Return `True` if `netmask` is a valid netmask string, and `False` otherwise.
    &#34;&#34;&#34;

    try:
        ipaddress.IPv4Network(&#39;0.0.0.0/{}&#39;.format(netmask))
    except ipaddress.NetmaskValueError:
        return False
    else:
        return True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kyanitapi.Kyanit"><code class="flex name class">
<span>class <span class="ident">Kyanit</span></span>
<span>(</span><span>color_id=None, network_addr=None, ip_addr=None, timeout=3)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for a Kyanit connection instance. No connection attempt is made on instantiation.</p>
<p>Provide either a Color ID with a Network address OR an IP address. These can not be changed
after instantiation. Timeout is in seconds.</p>
<p>If both Color ID and IP address are provided, <code>ValueError: bad connection method</code> will be
raised. If neither is provided, <code>ValueError: no connection method</code> will be raised.</p>
<p>All methods that perform a request towards Kyanit will be blocking until a response is received
or the request is timed out.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Kyanit:
    &#34;&#34;&#34;
    Class for a Kyanit connection instance. No connection attempt is made on instantiation.

    Provide either a Color ID with a Network address OR an IP address. These can not be changed
    after instantiation. Timeout is in seconds.

    If both Color ID and IP address are provided, `ValueError: bad connection method` will be
    raised. If neither is provided, `ValueError: no connection method` will be raised.

    All methods that perform a request towards Kyanit will be blocking until a response is received
    or the request is timed out.
    &#34;&#34;&#34;

    def __init__(self, color_id=None, network_addr=None, ip_addr=None, timeout=3):
        if color_id is not None and ip_addr is not None:
            raise ValueError(&#39;bad connection method&#39;)
        elif color_id is None and ip_addr is None:
            raise ValueError(&#39;no connection method&#39;)
        
        if color_id is not None:
            self._ip_addr = cid_to_ip(color_id, network_addr=network_addr)
            self._color_id = color_id
        
        elif ip_addr is not None:
            self._color_id = ip_to_cid(ip_addr)
            self._ip_addr = ip_addr

        self._network_addr = network_addr
        self.set_timeout(timeout)
    
    def info(self):
        &#34;&#34;&#34;
        Return connection info.

        Return value is a dict with the following schema:

        ```python
        {
            &#39;color_id&#39;: str,
            &#39;network_addr&#39;: str,
            &#39;ip_addr&#39;: str
        }
        ```
        &#34;&#34;&#34;

        return {
            &#39;color_id&#39;: self._color_id,
            &#39;network_addr&#39;: self._network_addr,
            &#39;ip_addr&#39;: self._ip_addr
        }
    
    def set_timeout(self, seconds):
        &#34;&#34;&#34;
        Set connection timeout in seconds.
        &#34;&#34;&#34;

        self._timeout = seconds
    
    def ping(self, count=3, timeout=1, verbose=False):
        &#34;&#34;&#34;
        Ping Kyanit.
        
        You may provide ping count and timeout in seconds. If verbose is `True`, results will be
        printed.

        Return value is `True` is ping was successful, `False` otherwise
        &#34;&#34;&#34;

        return pythonping.ping(self._ip_addr,
                               count=count,
                               timeout=timeout,
                               verbose=verbose).success()

    def get_status(self, tries=1):
        &#34;&#34;&#34;
        Get status of Kyanit. Getting status will be attempted a number of times defined in `tries`.
        Each try may time out, therefore getting status may take `tries * self.timeout` amount of
        time. (Useful after some longer operation, ex. directly after reboot.)

        Returned value will be a dict with the following schema:

        ```python
        {
            &#39;firmware_version&#39;: str,  # version number in the format major.minor.patch
            &#39;color_id&#39;: str,  # current Color ID of the Kyanit
            &#39;free_memory&#39;: int,  # free heap RAM in bytes
            &#39;free_flash&#39;: int,  # amount of bytes free in the filesystem
            &#39;run_state&#39;: str,  # see note below
            &#39;error_traceback&#39;: [
                str
            ] # key is present if run_state is ERROR, and contains the traceback lines
        }
        ```

        Note: for possible run states see https://github.com/kyanit-project/kyanit#run-states
        &#34;&#34;&#34;
        
        num_tries = 0
        while True:
            try:
                data = requests.get(&#39;http://{}:3300/sys/state&#39;.format(self._ip_addr),
                                    timeout=self._timeout)
            except Exception:
                num_tries += 1
                if num_tries &gt;= tries:
                    break
            else:
                return data.json()
        raise KyanitConnectionError
    
    @_request_handler(&#39;json&#39;)
    def stop(self, force=False):
        &#34;&#34;&#34;
        Stop runner, stopping all tasks. New run state will be &#39;STOPPED&#39;.

        A kyanit.StoppedError will be passed to code.cleanup on Kyanit.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.post(&#39;http://{}:3300/sys/stop{}&#39;
                             .format(self._ip_addr, &#39;/force&#39; if force else &#39;&#39;),
                             timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def start(self):
        &#34;&#34;&#34;
        Start runner. Kyanit will attempt to import &#39;code.py&#39; and call main.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.post(&#39;http://{}:3300/sys/start&#39;.format(self._ip_addr),
                             timeout=self._timeout)
    
    # @_request_handler(&#39;json&#39;)
    # def reset(self, soft=False):
    #     &#34;&#34;&#34;
    #     Perform a soft reset on the Kyanit. The system will restart, but the wlan connection will
    #     be preserved, if unchanged.

    #     kyanit.ResetError will be passed to code.cleanup on Kyanit before the reset procedure.

    #     Might take some time before Kyanit will respond to further requests. It&#39;s a good practice
    #     to `get_status` with a number of tries larger than 1 (ex. 5) after reboot or reset.

    #     Return value is the string `OK` if successful.
    #     &#34;&#34;&#34;

    #     return requests.post(&#39;http://{}:3300/sys/reboot/soft&#39;.format(self._ip_addr),
    #                          timeout=self._timeout)

    @_request_handler(&#39;json&#39;)
    def reboot(self):
        &#34;&#34;&#34;
        Perform a hard reset on the Kyanit. The system will fully restart, wlan connection will
        be performed again.

        kyanit.RebootError will be passed to code.cleanup on Kyanit before the reboot procedure.

        Might take some time before Kyanit will respond to further requests. It&#39;s a good practice to
        `get_status` with a number of tries larger than 1 (ex. 5) after reboot or reset.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.post(&#39;http://{}:3300/sys/reboot&#39;.format(self._ip_addr),
                             timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def get_file_list(self):
        &#34;&#34;&#34;
        Return a list with all of the file names present on Kyanit.
        &#34;&#34;&#34;

        return requests.get(&#39;http://{}:3300/files&#39;.format(self._ip_addr),
                            timeout=self._timeout)
    
    @_request_handler()
    def get_file(self, filename):
        &#34;&#34;&#34;
        Get the contents of the file with the name passed to `filename` from Kyanit.

        `KyanitRequestError` with status code 404 will be raised if file is not found.

        Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
        raised with a status code 500. The same error will be raised if trying to get `main.py`,
        `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

        Return type is bytes (the contents of the file).
        &#34;&#34;&#34;

        return requests.get(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename),
                            timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def put_file(self, filename, content):
        &#34;&#34;&#34;
        Create or replace a file with the name passed to `filename` on the Kyanit, and upload
        contents passed to `content`, which may be bytes or string.

        Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
        raised with a status code 500. The same error will be raised if trying to put `main.py`,
        `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.put(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename), content,
                            timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def delete_file(self, filename):
        &#34;&#34;&#34;
        Delete a file with the name passed to `filename` on the Kyanit.

        `KyanitRequestError` with status code 404 will be raised if file is not found.

        Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
        raised with a status code 500. The same error will be raised if trying to delete
        `main.py`, `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

        Return value is the string `OK` if successful.
        &#34;&#34;&#34;

        return requests.delete(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename),
                               timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def rename_file(self, filename, newname):
        &#34;&#34;&#34;
        Rename a file with the name passed to `filename` to `newname` on the Kyanit.

        `KyanitRequestError` with status code 404 will be raised if file is not found.

        Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
        raised with a status code 500. The same error will be raised if trying to rename
        `main.py`, `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.
        &#34;&#34;&#34;

        return requests.put(&#39;http://{}:3300/files/{}?rename={}&#39;
                            .format(self._ip_addr, filename, newname),
                            timeout=self._timeout)
    
    @_request_handler(&#39;json&#39;)
    def netvar(self, obj=None, clear=False):
        &#34;&#34;&#34;
        Read or write the Netvar on Kyanit.

        If `obj` is `None`, return the value of Netvar.outbound() from Kyanit.

        If `obj` is other than `None`, set the value of Netvar.inbound() on the Kyanit. In that case
        return value is the string &#39;OK&#39; if successful. Otherwise `TypeError` will be raised if `obj`
        is not JSON serializable.

        If `clear` is `True`, `obj` is disregarded and Netvar.inbound() will be set to `None` on the
        Kyanit.

        Examples:

        Get Netvar.inbound() with:

        ```python
        Kyanit.netvar()
        ```

        Set Netvar.outbound() with:

        ```python
        Kyanit.netvar(&#39;new_value&#39;)  # new_value can be any Python object that&#39;s JSON serializable
        ```

        Clear Netvar.outbound() with:

        ```python
        Kyanit.netvar(clear=True)
        ```

        See https://github.com/kyanit-project/kyanit#the-netvar for more on Netvar.
        &#34;&#34;&#34;

        if clear:
            return requests.post(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr), json.dumps(None),
                                 timeout=self._timeout)

        if obj is None:
            return requests.get(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr),
                                timeout=self._timeout)
        else:
            return requests.post(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr), json.dumps(obj),
                                 timeout=self._timeout)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="kyanitapi.Kyanit.delete_file"><code class="name flex">
<span>def <span class="ident">delete_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Delete a file with the name passed to <code>filename</code> on the Kyanit.</p>
<p><a title="kyanitapi.KyanitRequestError" href="#kyanitapi.KyanitRequestError"><code>KyanitRequestError</code></a> with status code 404 will be raised if file is not found.</p>
<p>Directories are not supported, if the filename contains a '/' <a title="kyanitapi.KyanitRequestError" href="#kyanitapi.KyanitRequestError"><code>KyanitRequestError</code></a> will be
raised with a status code 500. The same error will be raised if trying to delete
<code>main.py</code>, <code>boot.py</code> or <code>_boot.py</code> as these files are protected and internal to Kyanit.</p>
<p>Return value is the string <code>OK</code> if successful.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler(&#39;json&#39;)
def delete_file(self, filename):
    &#34;&#34;&#34;
    Delete a file with the name passed to `filename` on the Kyanit.

    `KyanitRequestError` with status code 404 will be raised if file is not found.

    Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
    raised with a status code 500. The same error will be raised if trying to delete
    `main.py`, `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

    Return value is the string `OK` if successful.
    &#34;&#34;&#34;

    return requests.delete(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename),
                           timeout=self._timeout)</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.get_file"><code class="name flex">
<span>def <span class="ident">get_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the contents of the file with the name passed to <code>filename</code> from Kyanit.</p>
<p><a title="kyanitapi.KyanitRequestError" href="#kyanitapi.KyanitRequestError"><code>KyanitRequestError</code></a> with status code 404 will be raised if file is not found.</p>
<p>Directories are not supported, if the filename contains a '/' <a title="kyanitapi.KyanitRequestError" href="#kyanitapi.KyanitRequestError"><code>KyanitRequestError</code></a> will be
raised with a status code 500. The same error will be raised if trying to get <code>main.py</code>,
<code>boot.py</code> or <code>_boot.py</code> as these files are protected and internal to Kyanit.</p>
<p>Return type is bytes (the contents of the file).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler()
def get_file(self, filename):
    &#34;&#34;&#34;
    Get the contents of the file with the name passed to `filename` from Kyanit.

    `KyanitRequestError` with status code 404 will be raised if file is not found.

    Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
    raised with a status code 500. The same error will be raised if trying to get `main.py`,
    `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

    Return type is bytes (the contents of the file).
    &#34;&#34;&#34;

    return requests.get(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename),
                        timeout=self._timeout)</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.get_file_list"><code class="name flex">
<span>def <span class="ident">get_file_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a list with all of the file names present on Kyanit.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler(&#39;json&#39;)
def get_file_list(self):
    &#34;&#34;&#34;
    Return a list with all of the file names present on Kyanit.
    &#34;&#34;&#34;

    return requests.get(&#39;http://{}:3300/files&#39;.format(self._ip_addr),
                        timeout=self._timeout)</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, tries=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Get status of Kyanit. Getting status will be attempted a number of times defined in <code>tries</code>.
Each try may time out, therefore getting status may take <code>tries * self.timeout</code> amount of
time. (Useful after some longer operation, ex. directly after reboot.)</p>
<p>Returned value will be a dict with the following schema:</p>
<pre><code class="python">{
    'firmware_version': str,  # version number in the format major.minor.patch
    'color_id': str,  # current Color ID of the Kyanit
    'free_memory': int,  # free heap RAM in bytes
    'free_flash': int,  # amount of bytes free in the filesystem
    'run_state': str,  # see note below
    'error_traceback': [
        str
    ] # key is present if run_state is ERROR, and contains the traceback lines
}
</code></pre>
<p>Note: for possible run states see <a href="https://github.com/kyanit-project/kyanit#run-states">https://github.com/kyanit-project/kyanit#run-states</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self, tries=1):
    &#34;&#34;&#34;
    Get status of Kyanit. Getting status will be attempted a number of times defined in `tries`.
    Each try may time out, therefore getting status may take `tries * self.timeout` amount of
    time. (Useful after some longer operation, ex. directly after reboot.)

    Returned value will be a dict with the following schema:

    ```python
    {
        &#39;firmware_version&#39;: str,  # version number in the format major.minor.patch
        &#39;color_id&#39;: str,  # current Color ID of the Kyanit
        &#39;free_memory&#39;: int,  # free heap RAM in bytes
        &#39;free_flash&#39;: int,  # amount of bytes free in the filesystem
        &#39;run_state&#39;: str,  # see note below
        &#39;error_traceback&#39;: [
            str
        ] # key is present if run_state is ERROR, and contains the traceback lines
    }
    ```

    Note: for possible run states see https://github.com/kyanit-project/kyanit#run-states
    &#34;&#34;&#34;
    
    num_tries = 0
    while True:
        try:
            data = requests.get(&#39;http://{}:3300/sys/state&#39;.format(self._ip_addr),
                                timeout=self._timeout)
        except Exception:
            num_tries += 1
            if num_tries &gt;= tries:
                break
        else:
            return data.json()
    raise KyanitConnectionError</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return connection info.</p>
<p>Return value is a dict with the following schema:</p>
<pre><code class="python">{
    'color_id': str,
    'network_addr': str,
    'ip_addr': str
}
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self):
    &#34;&#34;&#34;
    Return connection info.

    Return value is a dict with the following schema:

    ```python
    {
        &#39;color_id&#39;: str,
        &#39;network_addr&#39;: str,
        &#39;ip_addr&#39;: str
    }
    ```
    &#34;&#34;&#34;

    return {
        &#39;color_id&#39;: self._color_id,
        &#39;network_addr&#39;: self._network_addr,
        &#39;ip_addr&#39;: self._ip_addr
    }</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.netvar"><code class="name flex">
<span>def <span class="ident">netvar</span></span>(<span>self, obj=None, clear=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read or write the Netvar on Kyanit.</p>
<p>If <code>obj</code> is <code>None</code>, return the value of Netvar.outbound() from Kyanit.</p>
<p>If <code>obj</code> is other than <code>None</code>, set the value of Netvar.inbound() on the Kyanit. In that case
return value is the string 'OK' if successful. Otherwise <code>TypeError</code> will be raised if <code>obj</code>
is not JSON serializable.</p>
<p>If <code>clear</code> is <code>True</code>, <code>obj</code> is disregarded and Netvar.inbound() will be set to <code>None</code> on the
Kyanit.</p>
<p>Examples:</p>
<p>Get Netvar.inbound() with:</p>
<pre><code class="python">Kyanit.netvar()
</code></pre>
<p>Set Netvar.outbound() with:</p>
<pre><code class="python">Kyanit.netvar('new_value')  # new_value can be any Python object that's JSON serializable
</code></pre>
<p>Clear Netvar.outbound() with:</p>
<pre><code class="python">Kyanit.netvar(clear=True)
</code></pre>
<p>See <a href="https://github.com/kyanit-project/kyanit#the-netvar">https://github.com/kyanit-project/kyanit#the-netvar</a> for more on Netvar.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler(&#39;json&#39;)
def netvar(self, obj=None, clear=False):
    &#34;&#34;&#34;
    Read or write the Netvar on Kyanit.

    If `obj` is `None`, return the value of Netvar.outbound() from Kyanit.

    If `obj` is other than `None`, set the value of Netvar.inbound() on the Kyanit. In that case
    return value is the string &#39;OK&#39; if successful. Otherwise `TypeError` will be raised if `obj`
    is not JSON serializable.

    If `clear` is `True`, `obj` is disregarded and Netvar.inbound() will be set to `None` on the
    Kyanit.

    Examples:

    Get Netvar.inbound() with:

    ```python
    Kyanit.netvar()
    ```

    Set Netvar.outbound() with:

    ```python
    Kyanit.netvar(&#39;new_value&#39;)  # new_value can be any Python object that&#39;s JSON serializable
    ```

    Clear Netvar.outbound() with:

    ```python
    Kyanit.netvar(clear=True)
    ```

    See https://github.com/kyanit-project/kyanit#the-netvar for more on Netvar.
    &#34;&#34;&#34;

    if clear:
        return requests.post(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr), json.dumps(None),
                             timeout=self._timeout)

    if obj is None:
        return requests.get(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr),
                            timeout=self._timeout)
    else:
        return requests.post(&#39;http://{}:3300/netvar&#39;.format(self._ip_addr), json.dumps(obj),
                             timeout=self._timeout)</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self, count=3, timeout=1, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Ping Kyanit.</p>
<p>You may provide ping count and timeout in seconds. If verbose is <code>True</code>, results will be
printed.</p>
<p>Return value is <code>True</code> is ping was successful, <code>False</code> otherwise</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(self, count=3, timeout=1, verbose=False):
    &#34;&#34;&#34;
    Ping Kyanit.
    
    You may provide ping count and timeout in seconds. If verbose is `True`, results will be
    printed.

    Return value is `True` is ping was successful, `False` otherwise
    &#34;&#34;&#34;

    return pythonping.ping(self._ip_addr,
                           count=count,
                           timeout=timeout,
                           verbose=verbose).success()</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.put_file"><code class="name flex">
<span>def <span class="ident">put_file</span></span>(<span>self, filename, content)</span>
</code></dt>
<dd>
<section class="desc"><p>Create or replace a file with the name passed to <code>filename</code> on the Kyanit, and upload
contents passed to <code>content</code>, which may be bytes or string.</p>
<p>Directories are not supported, if the filename contains a '/' <a title="kyanitapi.KyanitRequestError" href="#kyanitapi.KyanitRequestError"><code>KyanitRequestError</code></a> will be
raised with a status code 500. The same error will be raised if trying to put <code>main.py</code>,
<code>boot.py</code> or <code>_boot.py</code> as these files are protected and internal to Kyanit.</p>
<p>Return value is the string <code>OK</code> if successful.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler(&#39;json&#39;)
def put_file(self, filename, content):
    &#34;&#34;&#34;
    Create or replace a file with the name passed to `filename` on the Kyanit, and upload
    contents passed to `content`, which may be bytes or string.

    Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
    raised with a status code 500. The same error will be raised if trying to put `main.py`,
    `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.

    Return value is the string `OK` if successful.
    &#34;&#34;&#34;

    return requests.put(&#39;http://{}:3300/files/{}&#39;.format(self._ip_addr, filename), content,
                        timeout=self._timeout)</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.reboot"><code class="name flex">
<span>def <span class="ident">reboot</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Perform a hard reset on the Kyanit. The system will fully restart, wlan connection will
be performed again.</p>
<p>kyanit.RebootError will be passed to code.cleanup on Kyanit before the reboot procedure.</p>
<p>Might take some time before Kyanit will respond to further requests. It's a good practice to
<code>get_status</code> with a number of tries larger than 1 (ex. 5) after reboot or reset.</p>
<p>Return value is the string <code>OK</code> if successful.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler(&#39;json&#39;)
def reboot(self):
    &#34;&#34;&#34;
    Perform a hard reset on the Kyanit. The system will fully restart, wlan connection will
    be performed again.

    kyanit.RebootError will be passed to code.cleanup on Kyanit before the reboot procedure.

    Might take some time before Kyanit will respond to further requests. It&#39;s a good practice to
    `get_status` with a number of tries larger than 1 (ex. 5) after reboot or reset.

    Return value is the string `OK` if successful.
    &#34;&#34;&#34;

    return requests.post(&#39;http://{}:3300/sys/reboot&#39;.format(self._ip_addr),
                         timeout=self._timeout)</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.rename_file"><code class="name flex">
<span>def <span class="ident">rename_file</span></span>(<span>self, filename, newname)</span>
</code></dt>
<dd>
<section class="desc"><p>Rename a file with the name passed to <code>filename</code> to <code>newname</code> on the Kyanit.</p>
<p><a title="kyanitapi.KyanitRequestError" href="#kyanitapi.KyanitRequestError"><code>KyanitRequestError</code></a> with status code 404 will be raised if file is not found.</p>
<p>Directories are not supported, if the filename contains a '/' <a title="kyanitapi.KyanitRequestError" href="#kyanitapi.KyanitRequestError"><code>KyanitRequestError</code></a> will be
raised with a status code 500. The same error will be raised if trying to rename
<code>main.py</code>, <code>boot.py</code> or <code>_boot.py</code> as these files are protected and internal to Kyanit.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler(&#39;json&#39;)
def rename_file(self, filename, newname):
    &#34;&#34;&#34;
    Rename a file with the name passed to `filename` to `newname` on the Kyanit.

    `KyanitRequestError` with status code 404 will be raised if file is not found.

    Directories are not supported, if the filename contains a &#39;/&#39; `KyanitRequestError` will be
    raised with a status code 500. The same error will be raised if trying to rename
    `main.py`, `boot.py` or `_boot.py` as these files are protected and internal to Kyanit.
    &#34;&#34;&#34;

    return requests.put(&#39;http://{}:3300/files/{}?rename={}&#39;
                        .format(self._ip_addr, filename, newname),
                        timeout=self._timeout)</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.set_timeout"><code class="name flex">
<span>def <span class="ident">set_timeout</span></span>(<span>self, seconds)</span>
</code></dt>
<dd>
<section class="desc"><p>Set connection timeout in seconds.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_timeout(self, seconds):
    &#34;&#34;&#34;
    Set connection timeout in seconds.
    &#34;&#34;&#34;

    self._timeout = seconds</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Start runner. Kyanit will attempt to import 'code.py' and call main.</p>
<p>Return value is the string <code>OK</code> if successful.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler(&#39;json&#39;)
def start(self):
    &#34;&#34;&#34;
    Start runner. Kyanit will attempt to import &#39;code.py&#39; and call main.

    Return value is the string `OK` if successful.
    &#34;&#34;&#34;

    return requests.post(&#39;http://{}:3300/sys/start&#39;.format(self._ip_addr),
                         timeout=self._timeout)</code></pre>
</details>
</dd>
<dt id="kyanitapi.Kyanit.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Stop runner, stopping all tasks. New run state will be 'STOPPED'.</p>
<p>A kyanit.StoppedError will be passed to code.cleanup on Kyanit.</p>
<p>Return value is the string <code>OK</code> if successful.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_request_handler(&#39;json&#39;)
def stop(self, force=False):
    &#34;&#34;&#34;
    Stop runner, stopping all tasks. New run state will be &#39;STOPPED&#39;.

    A kyanit.StoppedError will be passed to code.cleanup on Kyanit.

    Return value is the string `OK` if successful.
    &#34;&#34;&#34;

    return requests.post(&#39;http://{}:3300/sys/stop{}&#39;
                         .format(self._ip_addr, &#39;/force&#39; if force else &#39;&#39;),
                         timeout=self._timeout)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="kyanitapi.KyanitConnectionError"><code class="flex name class">
<span>class <span class="ident">KyanitConnectionError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised when connecting to Kyanit fails or results in a timeout. No arguments are passed to
this exception.</p>
<p>Handle it as follows:</p>
<pre><code class="python">try:
    # some Kyanit operation
    ...
except KyanitConnectionError:
    # do something on connection error
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KyanitConnectionError(Exception):
    &#34;&#34;&#34;
    Raised when connecting to Kyanit fails or results in a timeout. No arguments are passed to
    this exception.

    Handle it as follows:

    ```python
    try:
        # some Kyanit operation
        ...
    except KyanitConnectionError:
        # do something on connection error
    ```
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="kyanitapi.KyanitRequestError"><code class="flex name class">
<span>class <span class="ident">KyanitRequestError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised when Kyanit responds with a status code other than 200 OK. The first argument passed
to this exception will be the response status code, the second will be the response body.</p>
<p>Handle it as follows:</p>
<pre><code class="python">try:
    # some Kyanit operation
    ...
except KyanitRequestError as error:
    status_code = error.args[0]
    response_body = error.args[1]

    if status_code == 404:
        # do something on 404 Not Found
        ...

    # handle the rest, if desired
    ...
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KyanitRequestError(Exception):
    &#34;&#34;&#34;
    Raised when Kyanit responds with a status code other than 200 OK. The first argument passed
    to this exception will be the response status code, the second will be the response body.

    Handle it as follows:

    ```python
    try:
        # some Kyanit operation
        ...
    except KyanitRequestError as error:
        status_code = error.args[0]
        response_body = error.args[1]
        
        if status_code == 404:
            # do something on 404 Not Found
            ...
        
        # handle the rest, if desired
        ...
    ```
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<img src="kyanit_api_logo.svg">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#kyanit-api">Kyanit API</a></li>
<li><a href="#license-notice">License Notice</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="kyanitapi.cid_is_valid" href="#kyanitapi.cid_is_valid">cid_is_valid</a></code></li>
<li><code><a title="kyanitapi.cid_to_ip" href="#kyanitapi.cid_to_ip">cid_to_ip</a></code></li>
<li><code><a title="kyanitapi.get_networks" href="#kyanitapi.get_networks">get_networks</a></code></li>
<li><code><a title="kyanitapi.ip_is_valid" href="#kyanitapi.ip_is_valid">ip_is_valid</a></code></li>
<li><code><a title="kyanitapi.ip_to_cid" href="#kyanitapi.ip_to_cid">ip_to_cid</a></code></li>
<li><code><a title="kyanitapi.netmask_is_valid" href="#kyanitapi.netmask_is_valid">netmask_is_valid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kyanitapi.Kyanit" href="#kyanitapi.Kyanit">Kyanit</a></code></h4>
<ul class="two-column">
<li><code><a title="kyanitapi.Kyanit.delete_file" href="#kyanitapi.Kyanit.delete_file">delete_file</a></code></li>
<li><code><a title="kyanitapi.Kyanit.get_file" href="#kyanitapi.Kyanit.get_file">get_file</a></code></li>
<li><code><a title="kyanitapi.Kyanit.get_file_list" href="#kyanitapi.Kyanit.get_file_list">get_file_list</a></code></li>
<li><code><a title="kyanitapi.Kyanit.get_status" href="#kyanitapi.Kyanit.get_status">get_status</a></code></li>
<li><code><a title="kyanitapi.Kyanit.info" href="#kyanitapi.Kyanit.info">info</a></code></li>
<li><code><a title="kyanitapi.Kyanit.netvar" href="#kyanitapi.Kyanit.netvar">netvar</a></code></li>
<li><code><a title="kyanitapi.Kyanit.ping" href="#kyanitapi.Kyanit.ping">ping</a></code></li>
<li><code><a title="kyanitapi.Kyanit.put_file" href="#kyanitapi.Kyanit.put_file">put_file</a></code></li>
<li><code><a title="kyanitapi.Kyanit.reboot" href="#kyanitapi.Kyanit.reboot">reboot</a></code></li>
<li><code><a title="kyanitapi.Kyanit.rename_file" href="#kyanitapi.Kyanit.rename_file">rename_file</a></code></li>
<li><code><a title="kyanitapi.Kyanit.set_timeout" href="#kyanitapi.Kyanit.set_timeout">set_timeout</a></code></li>
<li><code><a title="kyanitapi.Kyanit.start" href="#kyanitapi.Kyanit.start">start</a></code></li>
<li><code><a title="kyanitapi.Kyanit.stop" href="#kyanitapi.Kyanit.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kyanitapi.KyanitConnectionError" href="#kyanitapi.KyanitConnectionError">KyanitConnectionError</a></code></h4>
</li>
<li>
<h4><code><a title="kyanitapi.KyanitRequestError" href="#kyanitapi.KyanitRequestError">KyanitRequestError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>